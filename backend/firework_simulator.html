<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Firework Simulator</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #111;
            color: white;
            font-family: Arial, sans-serif;
        }
        
        .container {
            display: flex;
            gap: 20px;
        }
        
        .controls {
            width: 300px;
            background: #222;
            padding: 20px;
            border-radius: 10px;
            height: fit-content;
        }
        
        .canvas-container {
            flex: 1;
            background: black;
            border-radius: 10px;
            overflow: hidden;
        }
        
        canvas {
            display: block;
            background: linear-gradient(to bottom, #000428, #004e92);
        }
        
        .charge-item {
            background: #333;
            padding: 15px;
            margin: 10px 0;
            border-radius: 8px;
            border-left: 4px solid #4CAF50;
        }
        
        .charge-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 10px;
        }
        
        select, button, input[type="color"] {
            padding: 8px;
            border: none;
            border-radius: 4px;
            background: #444;
            color: white;
            cursor: pointer;
        }
        
        button {
            background: #4CAF50;
            font-weight: bold;
        }
        
        button:hover {
            background: #45a049;
        }
        
        .remove-btn {
            background: #f44336;
            grid-column: span 2;
        }
        
        .remove-btn:hover {
            background: #da190b;
        }
        
        .launch-btn {
            background: #FF9800;
            font-size: 18px;
            padding: 15px;
            margin: 20px 0;
            width: 100%;
        }
        
        .launch-btn:hover {
            background: #F57C00;
        }
        
        h2 {
            color: #4CAF50;
            border-bottom: 2px solid #4CAF50;
            padding-bottom: 10px;
        }
        
        h3 {
            color: #FFA726;
            margin-bottom: 15px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="controls">
            <h2>Firework Designer</h2>
            
            <h3>Add New Charge</h3>
            <div class="charge-controls">
                <select id="newChargeType">
                    <option value="0">Normal</option>
                    <option value="1">Fire Charge</option>
                    <option value="2">Star</option>
                    <option value="3">Creeper</option>
                    <option value="4">Burst</option>
                </select>
                
                <select id="newChargeEffect">
                    <option value="0">Normal</option>
                    <option value="1">Trail</option>
                    <option value="2">Twinkle</option>
                    <option value="3">Trail + Twinkle</option>
                </select>
                
                <select id="newChargeColor">
                    <option value="#B02E26">Red</option>
                    <option value="#F9801D">Orange</option>
                    <option value="#FED83D">Yellow</option>
                    <option value="#80C71F">Lime</option>
                    <option value="#5E7C16">Green</option>
                    <option value="#169C9C">Cyan</option>
                    <option value="#3AB3DA">Light Blue</option>
                    <option value="#3C44AA">Blue</option>
                    <option value="#8932B8">Purple</option>
                    <option value="#C74EBD">Magenta</option>
                    <option value="#F38BAA">Pink</option>
                    <option value="#F9FFFE">White</option>
                    <option value="#9D9D97">Light Gray</option>
                    <option value="#474F52">Gray</option>
                    <option value="#1D1D21">Black</option>
                    <option value="#835432">Brown</option>
                </select>
                <button onclick="addCharge()">Add Charge</button>
            </div>
            
            <button class="launch-btn" onclick="launchFirework()">ðŸŽ† Launch Firework!</button>
            
            <h3>Current Charges</h3>
            <div id="chargesList"></div>
            
            <div style="margin-top: 20px; padding: 15px; background: #333; border-radius: 8px;">
                <h3>Instructions</h3>
                <p><strong>Types:</strong></p>
                <ul style="margin: 5px 0; padding-left: 20px; font-size: 14px;">
                    <li><strong>Normal:</strong> Basic circular explosion</li>
                    <li><strong>Fire Charge:</strong> Large, intense explosion</li>
                    <li><strong>Star:</strong> 5-pointed star pattern</li>
                    <li><strong>Creeper:</strong> Minecraft creeper face</li>
                    <li><strong>Burst:</strong> Quick, bright flash</li>
                </ul>
                <p><strong>Effects:</strong></p>
                <ul style="margin: 5px 0; padding-left: 20px; font-size: 14px;">
                    <li><strong>Trail:</strong> Particles leave fading trails</li>
                    <li><strong>Twinkle:</strong> Particles sparkle randomly</li>
                    <li><strong>Trail + Twinkle:</strong> Both effects combined</li>
                </ul>
            </div>
        </div>
        
        <div class="canvas-container">
            <canvas id="fireworkCanvas" width="800" height="600"></canvas>
        </div>
    </div>

    <script>
        // Constants
        const Type = {
            NORMAL: 0,
            FIRE_CHARGE: 1,
            STAR: 2,
            CREEPER: 3,
            BURST: 4
        };

        const Effects = {
            NORMAL: 0,
            TRAIL: 1,
            TWINKLE: 2,
            TRAIL_TWINKLE: 3
        };

        const Colours = {
            WHITE: "#F9FFFE",
            LIGHT_GRAY: "#9D9D97",
            GRAY: "#474F52",
            BLACK: "#1D1D21",
            BROWN: "#835432",
            RED: "#B02E26",
            ORANGE: "#F9801D",
            YELLOW: "#FED83D",
            LIME: "#80C71F",
            GREEN: "#5E7C16",
            CYAN: "#169C9C",
            LIGHT_BLUE: "#3AB3DA",
            BLUE: "#3C44AA",
            PURPLE: "#8932B8",
            MAGENTA: "#C74EBD",
            PINK: "#F38BAA"
        };

        // Canvas setup
        const canvas = document.getElementById('fireworkCanvas');
        const ctx = canvas.getContext('2d');
        
        // Global variables
        let charges = [];
        let currentFirework = null;
        let lastTime = performance.now();
        let animationId = null;
        let particleImages = [];
        let rocketImage = null;
        let imagesLoaded = false;

        // Load actual asset images
        function loadAssetImages() {
            let loadedCount = 0;
            const totalImages = 7; // 6 particle images + 1 rocket
            
            // Load particle images (0.png through 5.png)
            particleImages = [];
            for (let i = 0; i < 6; i++) {
                const img = new Image();
                img.onload = () => {
                    loadedCount++;
                    checkAllImagesLoaded();
                };
                img.onerror = () => {
                    console.error(`Failed to load particle image ${i}.png`);
                    loadedCount++;
                    checkAllImagesLoaded();
                };
                img.src = `assets/firework/${i}.png`;
                particleImages.push(img);
            }
            
            // Reverse array to match Python behavior
            particleImages.reverse();
            
            // Load rocket image
            rocketImage = new Image();
            rocketImage.onload = () => {
                loadedCount++;
                checkAllImagesLoaded();
            };
            rocketImage.onerror = () => {
                console.error('Failed to load rocket.png');
                loadedCount++;
                checkAllImagesLoaded();
            };
            rocketImage.src = 'assets/firework/rocket.png';
            
            function checkAllImagesLoaded() {
                if (loadedCount >= totalImages) {
                    imagesLoaded = true;
                    console.log('All firework assets loaded successfully!');
                }
            }
        }

        // Cache for colored particle images to avoid recreating them
        const coloredImageCache = new Map();
        
        function createColoredParticleImages(color) {
            if (color === Colours.WHITE || color === '#ffffff' || color === '#F9FFFE') {
                return particleImages;
            }
            
            // Check cache first
            if (coloredImageCache.has(color)) {
                return coloredImageCache.get(color);
            }
            
            const coloredImages = [];
            
            for (let originalImage of particleImages) {
                const canvas = document.createElement('canvas');
                canvas.width = originalImage.width;
                canvas.height = originalImage.height;
                const ctx = canvas.getContext('2d');
                
                // Convert hex color to RGB for proper blending
                const r = parseInt(color.slice(1, 3), 16);
                const g = parseInt(color.slice(3, 5), 16);
                const b = parseInt(color.slice(5, 7), 16);
                
                // Create ImageData for pixel manipulation
                ctx.drawImage(originalImage, 0, 0);
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageData.data;
                
                // Apply color tint while preserving transparency
                for (let i = 0; i < data.length; i += 4) {
                    if (data[i + 3] > 0) { // Only process non-transparent pixels
                        data[i] = Math.floor((data[i] / 255) * r);     // Red
                        data[i + 1] = Math.floor((data[i + 1] / 255) * g); // Green
                        data[i + 2] = Math.floor((data[i + 2] / 255) * b); // Blue
                        // Alpha (data[i + 3]) remains unchanged
                    }
                }
                
                ctx.putImageData(imageData, 0, 0);
                coloredImages.push(canvas);
            }
            
            // Cache the result
            coloredImageCache.set(color, coloredImages);
            return coloredImages;
        }

        // Classes
        class Star {
            constructor(type, effects, color) {
                this.type = type;
                this.effects = effects;
                this.color = color;
            }
        }

        class TrailParticle {
            constructor(position, lifespan, color, size, parentEffects = Effects.NORMAL, particleImages = null) {
                this.position = [position[0], position[1]];
                this.lifespan = lifespan;
                this.age = 0;
                this.color = color;
                this.size = size;
                this.parentEffects = parentEffects;
                // Reuse passed particle images instead of creating new ones
                this.particleImages = particleImages || createColoredParticleImages(color);
            }

            update(deltaTime) {
                this.age += deltaTime;
                return this.age < this.lifespan;
            }

            draw(ctx) {
                if (this.age >= this.lifespan) return;

                const fadeFactor = 1.0 - (this.age / this.lifespan);
                if (fadeFactor < 0.01) return;

                let imageIndex;
                if (this.parentEffects === Effects.TRAIL_TWINKLE) {
                    // For trail+twinkle: randomize image selection for sparkly trail
                    imageIndex = Math.floor(Math.random() * this.particleImages.length);
                } else {
                    // Normal trail: fade-based image selection
                    imageIndex = Math.floor((1.0 - fadeFactor) * (this.particleImages.length - 1));
                    imageIndex = Math.max(0, Math.min(imageIndex, this.particleImages.length - 1));
                }

                const image = this.particleImages[imageIndex];
                const alpha = fadeFactor * fadeFactor; // Quadratic fade
                
                ctx.save();
                ctx.globalAlpha = alpha;
                
                // Draw at original size like Python version
                ctx.drawImage(
                    image,
                    Math.floor(this.position[0] - image.width / 2),
                    Math.floor(this.position[1] - image.height / 2)
                );
                ctx.restore();
            }
        }

        class Particle {
            constructor(parent, position, vx, vy, size, lifespan, color = Colours.WHITE, gravity = 0.1, effects = Effects.NORMAL) {
                this.position = [...position];
                this.parent = parent;
                this.velocity = [vx, vy];
                this.color = color;
                this.size = size;
                this.lifespan = lifespan;
                this.age = 0;
                this.gravity = gravity;
                this.effects = effects;
                this.trailParticles = [];
                this.trailSpawnTimer = 0;
                // Cache the colored images once
                this.particleImages = createColoredParticleImages(color);
            }

            update(deltaTime) {
                // Physics update
                this.velocity[1] += this.gravity * deltaTime * 60;
                this.position[0] += this.velocity[0] * deltaTime;
                this.position[1] += this.velocity[1] * deltaTime;

                // Damping
                const dampingFactor = Math.pow(0.98, deltaTime * 60);
                this.velocity[0] *= dampingFactor;
                this.velocity[1] *= dampingFactor;

                // Trail effect
                if (this.effects === Effects.TRAIL || this.effects === Effects.TRAIL_TWINKLE) {
                    this.trailSpawnTimer += deltaTime;
                    const velocityMagnitude = Math.sqrt(this.velocity[0] ** 2 + this.velocity[1] ** 2);
                    const spawnInterval = Math.max(0.008, Math.min(0.02, 0.01 + velocityMagnitude * 0.00001));

                    if (this.trailSpawnTimer >= spawnInterval) {
                        const trailLifespan = 0.12;
                        // Pass cached images to avoid recreation
                        const trailParticle = new TrailParticle([...this.position], trailLifespan, this.color, this.size, this.effects, this.particleImages);
                        this.trailParticles.push(trailParticle);
                        this.trailSpawnTimer = 0;
                    }

                    // Update trail particles
                    this.trailParticles = this.trailParticles.filter(tp => tp.update(deltaTime));
                }

                this.age += deltaTime;
            }

            isExpired() {
                return this.age >= this.lifespan;
            }

            draw(ctx) {
                // Draw trail particles first
                if (this.effects === Effects.TRAIL || this.effects === Effects.TRAIL_TWINKLE) {
                    this.trailParticles.forEach(trail => trail.draw(ctx));
                }

                // Draw main particle using texture
                let imageIndex;
                if (this.effects === Effects.TWINKLE || this.effects === Effects.TRAIL_TWINKLE) {
                    // Twinkle: randomize the displayed image
                    imageIndex = Math.floor(Math.random() * this.particleImages.length);
                } else {
                    // Normal: age-based image selection with bounds checking
                    const ageRatio = Math.min(1.0, this.age / this.lifespan);
                    imageIndex = Math.floor(ageRatio * (this.particleImages.length - 1));
                }

                const image = this.particleImages[imageIndex];
                ctx.drawImage(
                    image,
                    Math.floor(this.position[0] - image.width / 2),
                    Math.floor(this.position[1] - image.height / 2)
                );
            }
        }

        class Firework {
            constructor(x, y, size, charges = []) {
                this.position = [x, y];
                this.originalY = y;
                this.size = size;
                this.duration = 1.3;
                this.particles = [];
                this.charges = charges;
                this.age = 0;
                this.hasExploded = false;
            }

            updateParticles(deltaTime) {
                this.particles = this.particles.filter(particle => {
                    particle.update(deltaTime);
                    return !particle.isExpired();
                });
            }

            drawParticles(ctx) {
                this.particles.forEach(particle => particle.draw(ctx));
            }

            update(deltaTime, ctx) {
                this.position[1] -= deltaTime * 400;

                if (this.age < this.duration) {
                    // Draw rocket using texture at smaller scale
                    if (rocketImage) {
                        const scale = 0.4; // Scale down to 40% of original size
                        const scaledWidth = rocketImage.width * scale;
                        const scaledHeight = rocketImage.height * scale;
                        ctx.drawImage(
                            rocketImage,
                            Math.floor(this.position[0] - scaledWidth / 2),
                            Math.floor(this.position[1] - scaledHeight / 2),
                            scaledWidth,
                            scaledHeight
                        );
                    }

                    // Spawn rocket trail particles
                    if (Math.random() < deltaTime * 20) {
                        this.particles.push(new Particle(
                            this,
                            [this.position[0], this.position[1] + 12],
                            (Math.random() - 0.5) * 60,
                            Math.random() * -8,
                            this.size,
                            0.4,
                            Colours.WHITE
                        ));
                    }
                    this.age += deltaTime;
                } else {
                    if (!this.hasExploded) {
                        this.hasExploded = true;
                        this.explode();
                    }
                }

                this.updateParticles(deltaTime);
            }

            explode() {
                for (const charge of this.charges) {
                    if (charge.type === Type.NORMAL || charge.type === Type.FIRE_CHARGE || charge.type === Type.BURST) {
                        let amount = 100;
                        let duration = 1;
                        let speedMultiplier = 1.0;

                        if (charge.type === Type.FIRE_CHARGE) {
                            amount = 150;
                            duration = 1.5;
                            speedMultiplier = 1.5;
                        }

                        for (let i = 0; i < amount; i++) {
                            const angle = Math.random() * 2 * Math.PI;
                            const speed = (Math.random() * 200 + 100) * speedMultiplier;
                            const vx = speed * Math.cos(angle);
                            const vy = speed * Math.sin(angle);

                            this.particles.push(new Particle(
                                this,
                                [...this.position],
                                vx, vy,
                                this.size,
                                duration + (Math.random() - 0.5),
                                charge.color,
                                1,
                                charge.effects
                            ));
                        }
                    } else if (charge.type === Type.STAR) {
                        this.createStar(charge);
                    } else if (charge.type === Type.CREEPER) {
                        this.createCreeper(charge);
                    }
                }
            }

            createStar(charge) {
                const duration = 1;
                const starSize = 60;
                const starPoints = [];

                // Generate star points
                for (let i = 0; i < 10; i++) {
                    const angle = (i * Math.PI / 5) - Math.PI / 2;
                    const radius = (i % 2 === 0) ? starSize : starSize * 0.4;
                    const x = radius * Math.cos(angle);
                    const y = radius * Math.sin(angle);
                    starPoints.push([x, y]);
                }

                // Create particles along star edges
                for (let i = 0; i < starPoints.length; i++) {
                    const currentPoint = starPoints[i];
                    const nextPoint = starPoints[(i + 1) % starPoints.length];
                    const particlesPerEdge = 15;

                    for (let j = 0; j < particlesPerEdge; j++) {
                        const t = j / (particlesPerEdge - 1);
                        const targetX = currentPoint[0] + t * (nextPoint[0] - currentPoint[0]) + (Math.random() - 0.5) * 6;
                        const targetY = currentPoint[1] + t * (nextPoint[1] - currentPoint[1]) + (Math.random() - 0.5) * 6;

                        const distance = Math.sqrt(targetX ** 2 + targetY ** 2);
                        if (distance > 0) {
                            const speed = distance * 4;
                            const vx = (targetX / distance) * speed;
                            const vy = (targetY / distance) * speed;

                            this.particles.push(new Particle(
                                this,
                                [...this.position],
                                vx, vy,
                                this.size,
                                duration + (Math.random() - 0.5) * 0.3,
                                charge.color,
                                1,
                                charge.effects
                            ));
                        }
                    }
                }
            }

            createCreeper(charge) {
                const creeperOutline = [
                    [1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1],
                    [1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],
                    [1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],
                    [1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],
                    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                    [0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0],
                    [0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0],
                    [0,0,1,1,1,1,0,0,0,0,1,1,1,1,0,0],
                    [0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,0],
                    [0,0,1,0,0,1,1,1,1,1,1,0,0,1,0,0],
                    [0,0,1,0,0,1,0,0,0,0,1,0,0,1,0,0],
                    [0,0,1,1,1,1,0,0,0,0,1,1,1,1,0,0]
                ];

                const duration = 1;
                const scaleFactor = 8;

                for (let row = 0; row < creeperOutline.length; row++) {
                    for (let col = 0; col < creeperOutline[row].length; col++) {
                        if (creeperOutline[row][col] === 1) {
                            const targetX = (col - 8) * scaleFactor;
                            const targetY = (row - 8) * scaleFactor * 1.1;

                            for (let p = 0; p < 3; p++) {
                                const finalX = targetX + (Math.random() - 0.5) * 8;
                                const finalY = targetY + (Math.random() - 0.5) * 8;

                                const distance = Math.sqrt(finalX ** 2 + finalY ** 2);
                                if (distance > 0) {
                                    const speed = distance * 4;
                                    const vx = (finalX / distance) * speed;
                                    const vy = (finalY / distance) * speed;

                                    this.particles.push(new Particle(
                                        this,
                                        [...this.position],
                                        vx, vy,
                                        this.size,
                                        duration + (Math.random() - 0.5) * 0.3,
                                        charge.color,
                                        1,
                                        charge.effects
                                    ));
                                }
                            }
                        }
                    }
                }
            }
        }

        // UI Functions
        function addCharge() {
            const type = parseInt(document.getElementById('newChargeType').value);
            const effects = parseInt(document.getElementById('newChargeEffect').value);
            const colorSelect = document.getElementById('newChargeColor');
            const color = colorSelect.value;

            charges.push(new Star(type, effects, color));
            updateChargesList();
        }

        function removeCharge(index) {
            charges.splice(index, 1);
            updateChargesList();
        }

        function updateChargesList() {
            const chargesList = document.getElementById('chargesList');
            chargesList.innerHTML = '';

            if (charges.length === 0) {
                chargesList.innerHTML = '<p style="color: #888; font-style: italic;">No charges added yet</p>';
                return;
            }

            charges.forEach((charge, index) => {
                const chargeDiv = document.createElement('div');
                chargeDiv.className = 'charge-item';
                
                const typeNames = ['Normal', 'Fire Charge', 'Star', 'Creeper', 'Burst'];
                const effectNames = ['Normal', 'Trail', 'Twinkle', 'Trail + Twinkle'];
                
                chargeDiv.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <div>
                            <strong>${typeNames[charge.type]}</strong><br>
                            <small>Effect: ${effectNames[charge.effects]}</small>
                        </div>
                        <div style="width: 30px; height: 30px; background: ${charge.color}; border-radius: 50%; border: 2px solid white;"></div>
                    </div>
                    <button class="remove-btn" onclick="removeCharge(${index})">Remove</button>
                `;
                
                chargesList.appendChild(chargeDiv);
            });
        }

        function launchFirework() {
            if (charges.length === 0) {
                alert('Please add at least one charge before launching!');
                return;
            }

            if (!imagesLoaded) {
                alert('Images are still loading, please wait a moment and try again!');
                return;
            }

            // Stop current animation if running
            if (animationId) {
                cancelAnimationFrame(animationId);
            }

            // Create new firework
            currentFirework = new Firework(canvas.width / 2, canvas.height - 20, 4, [...charges]);
            lastTime = performance.now();
            
            // Start animation
            animate();
        }

        function animate() {
            const currentTime = performance.now();
            const deltaTime = Math.min((currentTime - lastTime) / 1000, 1/30); // Cap at 30 FPS minimum
            lastTime = currentTime;

            // Clear canvas
            ctx.fillStyle = 'rgba(0, 4, 40, 0.1)'; // Slight fade effect
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Update and draw firework
            if (currentFirework) {
                currentFirework.update(deltaTime, ctx);
                currentFirework.drawParticles(ctx);

                // Continue animation if firework is still active
                if (currentFirework.particles.length > 0 || !currentFirework.hasExploded) {
                    animationId = requestAnimationFrame(animate);
                } else {
                    animationId = null;
                    // Clear canvas completely when done
                    setTimeout(() => {
                        ctx.fillStyle = 'rgba(0, 4, 40, 1)';
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                    }, 1000);
                }
            }
        }

        // Initialize images and setup
        function initializeApp() {
            // Load actual asset images
            loadAssetImages();

            // Initialize with some default charges
            charges = [
                new Star(Type.FIRE_CHARGE, Effects.NORMAL, Colours.RED),
                new Star(Type.STAR, Effects.TWINKLE, Colours.YELLOW),
                new Star(Type.CREEPER, Effects.TRAIL, Colours.GREEN)
            ];

            // Initialize UI
            updateChargesList();

            // Initial canvas clear
            ctx.fillStyle = 'rgba(0, 4, 40, 1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            console.log('Firework simulator initializing...');
        }

        // Initialize the app
        initializeApp();

        // Handle window resize
        function resizeCanvas() {
            const container = canvas.parentElement;
            const rect = container.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = Math.max(600, rect.height);
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
    </script>
</body>
</html>